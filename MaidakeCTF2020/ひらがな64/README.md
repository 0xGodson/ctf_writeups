# ひらがな64:Crypt:300pts
Flagを暗号化()しました。  
Hint  
BASE64のひらがなバージョンです。  
[flag.txt](flag.txt)　　　　[encrypt.py](encrypt.py)  

# Solution
暗号化されたフラグと、暗号化スクリプトが渡される。  
base64と同様の変換をひらがなで行っているようだ。  
以下のように変換されていた。  
```text
とぬかれはきかわはなせなつりんなひきにみふぬにやひきかぁひぬせぱねぺざらねぴこいなぴなぺせかざめへらにみへぽにぉへくこれへぺよぁはぺぇぎねぽせれふねいをはねぴ☆
```
encrypt.pyの中に以下のような変換テーブルがある。  
```python
~~~
TABLE = {
    '000000': 'あ', '000001': 'い', '000010': 'う', '000011': 'え', '000100': 'お',
    '000101': 'か', '000110': 'き', '000111': 'く', '001000': 'け', '001001': 'こ',
    '001010': 'さ', '001011': 'し', '001100': 'す', '001101': 'せ', '001110': 'そ',
    '001111': 'た', '010000': 'ち', '010001': 'つ', '010010': 'て', '010011': 'と',
    '010100': 'な', '010101': 'に', '010110': 'ぬ', '010111': 'ね', '011000': 'の',
    '011001': 'は', '011010': 'ひ', '011011': 'ふ', '011100': 'へ', '011101': 'ほ',
    '011110': 'ま', '011111': 'み', '100000': 'む', '100001': 'め', '100010': 'も',
    '100011': 'や', '100100': 'ゆ', '100101': 'よ',
    '100110': 'ら', '100111': 'り', '101000': 'る', '101001': 'れ', '101010': 'ろ',
    '101011': 'わ', '101100': 'を', '101101': 'ん',
    '101110': 'ぁ', '101111': 'ぃ', '110000': 'ぅ', '110001': 'ぇ', '110010': 'ぉ',
    '110011': 'ぱ', '110100': 'ぴ', '110101': 'ぷ', '110110': 'ぺ', '110111': 'ぽ',
    '111000': 'が', '111001': 'ぎ', '111010': 'ぐ', '111011': 'げ', '111100': 'ご',
    '111101': 'ざ', '111110': 'じ', '111111': 'ず',
}
~~~
```
flag.txtの中の文字列を逆に変換してやれば、ビット列が手に入る(☆は無視)。  
以下のesab64.pyで復号を行う。  
```python:esab64.py
table = [('000000','あ'), ('000001','い'), ('000010','う'), ('000011','え'), ('000100','お'), ('000101','か'), ('000110','き'), ('000111','く'), ('001000','け'), ('001001','こ'), ('001010','さ'), ('001011','し'), ('001100','す'), ('001101','せ'), ('001110','そ'), ('001111','た'), ('010000','ち'), ('010001','つ'), ('010010','て'), ('010011','と'), ('010100','な'), ('010101','に'), ('010110','ぬ'), ('010111','ね'), ('011000','の'), ('011001','は'), ('011010','ひ'), ('011011','ふ'), ('011100','へ'), ('011101','ほ'), ('011110','ま'), ('011111','み'), ('100000','む'), ('100001','め'), ('100010','も'), ('100011','や'), ('100100','ゆ'), ('100101','よ'), ('100110','ら'), ('100111','り'), ('101000','る'), ('101001','れ'), ('101010','ろ'), ('101011','わ'), ('101100','を'), ('101101','ん'), ('101110','ぁ'), ('101111','ぃ'), ('110000','ぅ'), ('110001','ぇ'), ('110010','ぉ'), ('110011','ぱ'), ('110100','ぴ'), ('110101','ぷ'), ('110110','ぺ'), ('110111','ぽ'), ('111000','が'), ('111001','ぎ'), ('111010','ぐ'), ('111011','げ'), ('111100','ご'), ('111101','ざ'), ('111110','じ'), ('111111','ず')]

hiragana = "とぬかれはきかわはなせなつりんなひきにみふぬにやひきかぁひぬせぱねぺざらねぴこいなぴなぺせかざめへらにみへぽにぉへくこれへぺよぁはぺぇぎねぽせれふねいをはねぴ"

for i in hiragana:
    for j in table:
        if j[1] == i:
            print(j[0], end="")
print()
```
```bash
$ python esab64.py
010011010110000101101001011001000110000101101011011001010100001101010100010001100111101101010100011010000110010101011111011011010110010101100011011010000110000101101110011010010110001101110011010111110110111101100110010111110100001001000001010100110100010100110110001101000101111101100001011100100110010101011111011100110111010101110010011100000111001001101001011100110110100101101110011001110110110001111001010111110111001101101001011011010111000001101100011001010111110100
```
ビット列を[Binary to Text Translator](https://www.rapidtables.com/convert/number/binary-to-ascii.html)でASCIIに変換するとflagが得られた。  

## MaidakeCTF{The_mechanics_of_BASE64_are_surprisingly_simple}